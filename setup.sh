#!/bin/bash
# Autonomous Supply Chain - Master Setup Script
# Run this ONCE to provision AlloyDB infrastructure and seed database
# Usage: sh setup.sh

set -e

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

echo "ğŸš€ Autonomous Supply Chain - Setup"
echo "===================================="
echo ""

# ============================================================================
# Helper Functions
# ============================================================================

# Spinner for long-running operations
spinner() {
    local pid=$1
    local delay=0.1
    local spinstr='|/-\'
    while ps -p $pid > /dev/null 2>&1; do
        local temp=${spinstr#?}
        printf " [%c]  " "$spinstr"
        local spinstr=$temp${spinstr%"$temp"}
        sleep $delay
        printf "\b\b\b\b\b\b"
    done
    printf "    \b\b\b\b"
}

# Load environment variables from .env file
load_env_file() {
    if [ -f "$SCRIPT_DIR/.env" ]; then
        echo "ğŸ“„ Loading existing .env file..."
        set -a
        source "$SCRIPT_DIR/.env"
        set +a
        echo "âœ… Environment variables loaded from .env"
        return 0
    fi
    return 1
}

# Write or update a single key in .env without touching other keys.
# Safe to call at any point â€” creates the file if it doesn't exist.
update_env_key() {
    local key=$1
    local value=$2
    local env_file="$SCRIPT_DIR/.env"
    if [ -f "$env_file" ]; then
        local content
        content=$(grep -v "^${key}=" "$env_file")
        printf '%s\n' "$content" > "$env_file"
    fi
    echo "${key}=${value}" >> "$env_file"
}

# Return one READY AlloyDB instance URI per line using gcloud JSON + Python.
# Uses a 20s subprocess timeout so it never hangs the polling loop.
check_ready_instances() {
    python3 -c "
import subprocess, json, sys
try:
    r = subprocess.run(
        ['gcloud', 'alloydb', 'instances', 'list', '--format=json'],
        capture_output=True, text=True, timeout=20)
    if r.returncode != 0:
        sys.exit(1)
    for i in json.loads(r.stdout or '[]'):
        if i.get('state') == 'READY':
            print(i['name'])
except Exception:
    sys.exit(1)
" 2>/dev/null
}

# Generate .env file with all configuration
generate_env_file() {
    local project=$1
    local api_key=$2
    local db_pass=$3
    local cluster=$4
    local instance=$5
    local region=$6
    
    cat > "$SCRIPT_DIR/.env" <<EOF
# Auto-generated by setup.sh on $(date)
# Autonomous Supply Chain - Environment Configuration

# ============================================================================
# Vision Agent - Gemini API Key (REQUIRED)
# ============================================================================
GEMINI_API_KEY=$api_key

# ============================================================================
# Supplier Agent - GCP Project (REQUIRED)
# ============================================================================
GOOGLE_CLOUD_PROJECT=$project

# ============================================================================
# AlloyDB Database (REQUIRED)
# ============================================================================
DB_PASS=$db_pass

# ============================================================================
# AlloyDB Connection Details (Auto-detected)
# ============================================================================
# These are for reference - the Auth Proxy handles the connection
ALLOYDB_CLUSTER=$cluster
ALLOYDB_INSTANCE=$instance
ALLOYDB_REGION=$region
ALLOYDB_PROJECT=$project

# Database connection via Auth Proxy (localhost)
DB_HOST=127.0.0.1
DB_PORT=5432
DB_USER=postgres
DB_NAME=postgres
EOF
    
    echo ""
    echo "âœ… Created .env file at: $SCRIPT_DIR/.env"
    echo "   All credentials saved for future runs"
}

# Parse AlloyDB instance URI to extract components
parse_instance_uri() {
    local uri=$1
    # Format: projects/PROJECT/locations/REGION/clusters/CLUSTER/instances/INSTANCE
    ALLOYDB_PROJECT=$(echo "$uri" | sed -n 's|projects/\([^/]*\).*|\1|p')
    ALLOYDB_REGION=$(echo "$uri" | sed -n 's|.*/locations/\([^/]*\).*|\1|p')
    ALLOYDB_CLUSTER=$(echo "$uri" | sed -n 's|.*/clusters/\([^/]*\).*|\1|p')
    ALLOYDB_INSTANCE=$(echo "$uri" | sed -n 's|.*/instances/\([^/]*\)|\1|p')
}

# Detect OS and architecture
detect_os() {
    case "$(uname -s)" in
        Linux*)     echo "linux";;
        Darwin*)    echo "darwin";;
        *)          echo "unknown";;
    esac
}

detect_arch() {
    case "$(uname -m)" in
        x86_64|amd64)   echo "amd64";;
        arm64|aarch64)  echo "arm64";;
        *)              echo "amd64";; # Default
    esac
}

# Try loading existing .env file first
load_env_file || true

# ============================================================================
# PRE-FLIGHT CHECKS - One error at a time, fail fast
# ============================================================================

echo "ğŸ” Running pre-flight checks..."
echo ""

preflight_fail() {
    local check="$1"
    local message="$2"
    local fix="$3"
    echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
    echo "âŒ  Pre-flight check failed: $check"
    echo ""
    echo "   $message"
    echo ""
    echo "   Fix:"
    echo "   $fix"
    echo ""
    echo "   Once fixed, re-run: sh setup.sh"
    echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
    exit 1
}

# Check 1: gcloud CLI
echo -n "Checking gcloud CLI... "
if command -v gcloud &> /dev/null; then
    echo "âœ…"
else
    echo "âŒ"
    preflight_fail "gcloud CLI not installed" \
        "The Google Cloud SDK (gcloud) is required to run this setup." \
        "Visit https://cloud.google.com/sdk/docs/install and follow the instructions."
fi

# Check 2: gcloud Authentication
echo -n "Checking gcloud authentication... "
ACTIVE_ACCOUNT=$(gcloud auth list --filter=status:ACTIVE --format="value(account)" 2>/dev/null)
if [ -n "$ACTIVE_ACCOUNT" ]; then
    echo "âœ… ($ACTIVE_ACCOUNT)"
else
    echo "âŒ"
    preflight_fail "Not authenticated with gcloud" \
        "You must sign in before this script can access Google Cloud." \
        "Run:  gcloud auth login
   This opens a browser to sign in. After signing in, re-run this script."
fi

# Check 3: GCP Project
echo -n "Checking GCP project... "
PROJECT=$(gcloud config get-value project 2>/dev/null)
if [ -n "$PROJECT" ]; then
    echo "âœ… ($PROJECT)"
    export GOOGLE_CLOUD_PROJECT=$PROJECT
else
    echo "âŒ"
    echo ""
    echo "   No GCP project is set. Please enter your Project ID to continue."
    echo "   (Find it at: https://console.cloud.google.com/)"
    echo ""
    read -p "   Enter your GCP Project ID: " PROJECT_INPUT
    if [ -z "$PROJECT_INPUT" ]; then
        preflight_fail "No GCP project configured" \
            "A GCP project must be set so this script knows where to provision resources." \
            "Run:  gcloud config set project YOUR_PROJECT_ID"
    fi
    gcloud config set project "$PROJECT_INPUT" 2>/dev/null
    PROJECT=$(gcloud config get-value project 2>/dev/null)
    if [ -n "$PROJECT" ]; then
        echo "   âœ… Project set to: $PROJECT"
        export GOOGLE_CLOUD_PROJECT=$PROJECT
    else
        preflight_fail "Failed to set GCP project" \
            "Could not set project to '$PROJECT_INPUT'." \
            "Run:  gcloud config set project YOUR_PROJECT_ID"
    fi
fi

# Check 4: Python 3
echo -n "Checking Python 3... "
if command -v python3 &> /dev/null; then
    PYTHON_VERSION=$(python3 --version 2>&1 | awk '{print $2}')
    echo "âœ… ($PYTHON_VERSION)"
else
    echo "âŒ"
    preflight_fail "Python 3 not found" \
        "Python 3 is required to run the database seeding scripts." \
        "Install Python 3 from https://www.python.org/downloads/ or via your package manager."
fi

# Check 5: pip3 (warning only - not fatal)
echo -n "Checking pip3... "
if command -v pip3 &> /dev/null; then
    echo "âœ…"
else
    echo "âš ï¸  (not found - will fall back to pip)"
fi

# Check 6: Git
echo -n "Checking git... "
if command -v git &> /dev/null; then
    echo "âœ…"
else
    echo "âŒ"
    preflight_fail "git not found" \
        "git is required to clone the AlloyDB infrastructure setup tool." \
        "Install git from https://git-scm.com/downloads or via your package manager."
fi

# Check 7: Billing (warning only - not fatal)
echo -n "Checking billing... "
BILLING_ENABLED=$(gcloud beta billing projects describe "$PROJECT" --format="value(billingEnabled)" 2>/dev/null || echo "false")
if [ "$BILLING_ENABLED" = "True" ] || [ "$BILLING_ENABLED" = "true" ]; then
    echo "âœ…"
else
    echo "âš ï¸  (billing may not be enabled)"
    echo "   Enable at: https://console.cloud.google.com/billing/linkedaccount?project=$PROJECT"
fi

# Check 8: Required APIs
echo ""
echo "Checking required APIs..."
REQUIRED_APIS=("aiplatform.googleapis.com" "alloydb.googleapis.com" "compute.googleapis.com" "servicenetworking.googleapis.com")
MISSING_APIS=()

for api in "${REQUIRED_APIS[@]}"; do
    echo -n "  - $api... "
    if gcloud services list --enabled --filter="name:$api" --format="value(name)" 2>/dev/null | grep -q "$api"; then
        echo "âœ…"
    else
        echo "âŒ"
        MISSING_APIS+=("$api")
    fi
done

echo ""
echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
if [ ${#MISSING_APIS[@]} -gt 0 ]; then
    echo "âš ï¸  Missing APIs detected: ${MISSING_APIS[*]}"
    echo ""
    read -p "Enable missing APIs automatically? (y/N): " -n 1 -r
    echo ""
    if [[ $REPLY =~ ^[Yy]$ ]]; then
        echo "Enabling APIs..."
        for api in "${MISSING_APIS[@]}"; do
            echo "  Enabling $api..."
            gcloud services enable "$api" --quiet
        done
        echo "âœ… All APIs enabled"
    else
        echo "âš ï¸  Continuing without enabling APIs (may fail later)"
    fi
else
    echo "âœ… All pre-flight checks passed!"
fi
echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
echo ""

# ============================================================================
# Step 1: Gemini API Key Setup & Validation
# ============================================================================
echo "ğŸ”‘ Step 1/5: Setting up Gemini API Key..."
echo ""

if [ -z "$GEMINI_API_KEY" ]; then
    echo "For Vision Agent (Gemini 3 Flash with Code Execution):"
    echo "  1. Visit: https://aistudio.google.com/apikey"
    echo "  2. Click 'Create API Key'"
    echo "  3. Paste below"
    echo ""
    read -p "Enter your Gemini API key (or press Enter to skip): " API_KEY_INPUT
    if [ -n "$API_KEY_INPUT" ]; then
        export GEMINI_API_KEY=$API_KEY_INPUT
        echo "âœ… API key configured"
    else
        echo "âš ï¸  Skipping API key - Vision Agent will not work"
    fi
else
    echo "âœ… Gemini API key found (loaded from .env or environment)"
fi

# Checkpoint 1: persist Gemini key + project so re-runs don't ask again
if [ -n "$GEMINI_API_KEY" ]; then
    update_env_key "GEMINI_API_KEY" "$GEMINI_API_KEY"
    update_env_key "GOOGLE_CLOUD_PROJECT" "$PROJECT"
fi

# Validate API key if provided
if [ -n "$GEMINI_API_KEY" ]; then
    echo ""
    echo -n "Validating Gemini API key... "
    # Simple validation: check if it's a reasonable format
    if [[ ${#GEMINI_API_KEY} -lt 20 ]]; then
        echo "âŒ"
        echo "   Error: API key seems too short (expected 30+ characters)"
        echo "   Please check your key and try again"
        exit 1
    else
        echo "âœ… (format valid)"
    fi
fi

echo ""

# ============================================================================
# Step 2: Python Dependencies
# ============================================================================
echo "ğŸ“¦ Step 2/5: Installing Python dependencies..."
echo ""

# Install database dependencies upfront
echo "Installing database libraries (psycopg2-binary, pgvector, google-genai)..."
if command -v pip3 &> /dev/null; then
    pip3 install -q psycopg2-binary pgvector python-dotenv google-genai 2>&1 | tail -1
else
    pip install -q psycopg2-binary pgvector python-dotenv google-genai 2>&1 | tail -1
fi
echo "âœ… Python dependencies installed"
echo ""

# ============================================================================
# Step 3: Check for Existing AlloyDB Instance
# ============================================================================
echo "ğŸ—ï¸  Step 3/5: Setting up AlloyDB infrastructure..."
echo ""

# First check if AlloyDB instance already exists
echo "ğŸ” Checking for existing AlloyDB instance..."
EXISTING_INSTANCES=$(gcloud alloydb instances list --filter="state:READY" --format="value(name)" 2>/dev/null || true)

if [ -n "$EXISTING_INSTANCES" ]; then
    INSTANCE_COUNT=$(echo "$EXISTING_INSTANCES" | wc -l | tr -d ' ')
    echo "âœ… Found $INSTANCE_COUNT existing AlloyDB instance(s)"
    echo ""
    echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
    echo "ğŸ“¦ Existing AlloyDB Instance(s) Detected"
    echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
    echo ""
    echo "Detected existing AlloyDB instance(s):"
    while IFS= read -r instance; do
        parse_instance_uri "$instance"
        echo "  â€¢ ${ALLOYDB_CLUSTER}/${ALLOYDB_INSTANCE} in ${ALLOYDB_REGION}"
    done <<< "$EXISTING_INSTANCES"
    echo ""
    echo "What would you like to do?"
    echo "  1) Use existing instance (recommended - saves 15 minutes)"
    echo "  2) Create a new instance (for separate projects/testing)"
    echo ""
    read -p "Enter your choice (1 or 2): " -n 1 -r INSTANCE_CHOICE
    echo ""
    echo ""
    
    if [[ $INSTANCE_CHOICE == "1" ]]; then
        echo "âœ… Will use existing instance"
        SKIP_INFRA_SETUP=true
    elif [[ $INSTANCE_CHOICE == "2" ]]; then
        echo "ğŸ“¦ Will provision a new instance (~15 minutes)"
        SKIP_INFRA_SETUP=false
    else
        echo "âš ï¸  Invalid choice. Defaulting to use existing instance (safer option)."
        SKIP_INFRA_SETUP=true
    fi
    echo ""
else
    echo "â„¹ï¸  No existing AlloyDB instance found"
    echo ""
    SKIP_INFRA_SETUP=false
fi

# Clone setup tool if needed (only if we need to provision)
if [ "$SKIP_INFRA_SETUP" = false ]; then
    if [ -d "$SCRIPT_DIR/easy-alloydb-setup" ]; then
        echo "âœ… Infrastructure tool already cloned"
    else
        echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
        echo "ğŸ“¦ AlloyDB Infrastructure Setup Tool"
        echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
        echo ""
        echo "We need to provision AlloyDB (VPC, Cluster, Instance)."
        echo ""
        echo "What we'll do:"
        echo "  â€¢ Clone a lightweight setup tool (easy-alloydb-setup)"
        echo "  â€¢ Source: https://github.com/AbiramiSukumaran/easy-alloydb-setup"
        echo "  â€¢ Purpose: Provides a web UI to configure and deploy AlloyDB"
        echo "  â€¢ Size: ~2 MB"
        echo ""
        echo "Why this tool?"
        echo "  â€¢ Manual AlloyDB setup takes 30+ steps and 45 minutes"
        echo "  â€¢ This tool automates VPC creation, peering, and cluster provisioning"
        echo "  â€¢ Provides a visual interface to track deployment progress"
        echo "  â€¢ Auto-configures network settings and security"
        echo ""
        echo "What gets cloned to: ./easy-alloydb-setup/"
        echo ""
        read -p "Clone the AlloyDB setup tool? (Y/n): " -n 1 -r
        echo ""
        if [[ $REPLY =~ ^[Nn]$ ]]; then
            echo "âŒ Cannot proceed without the infrastructure tool"
            echo "   You can manually provision AlloyDB and update .env"
            exit 1
        fi
        echo ""
        echo "ğŸ“¥ Cloning AlloyDB setup tool..."
        git clone https://github.com/AbiramiSukumaran/easy-alloydb-setup.git "$SCRIPT_DIR/easy-alloydb-setup" --quiet
        echo "âœ… Cloned successfully to ./easy-alloydb-setup/"
    fi

    chmod +x "$SCRIPT_DIR/easy-alloydb-setup/create_alloydb.sh" 2>/dev/null || true

    echo ""
    echo "ğŸŒ Starting infrastructure setup UI..."
    echo ""
    echo "â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”"
    echo "â”‚  IMPORTANT: Setup Instructions                      â”‚"
    echo "â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤"
    echo "â”‚  1. Click Web Preview (ğŸ‘ï¸) â†’ Preview on port 8080  â”‚"
    echo "â”‚  2. Enter your Project ID: $PROJECT"
    echo "â”‚  3. Select Region (e.g., us-central1)               â”‚"
    echo "â”‚  4. Set Database Password & SAVE IT!                â”‚"
    echo "â”‚  5. Click 'Start Deployment' and wait ~15 minutes   â”‚"
    echo "â”‚                                                      â”‚"
    echo "â”‚  âœ… This terminal will automatically continue       â”‚"
    echo "â”‚     once AlloyDB is READY â€” no Ctrl+C needed!       â”‚"
    echo "â”‚                                                      â”‚"
    echo "â”‚  âš ï¸  Keep this browser tab ACTIVE while waiting.   â”‚"
    echo "â”‚     If the terminal is disconnected, just re-run:   â”‚"
    echo "â”‚     sh setup.sh  (it auto-detects existing cluster) â”‚"
    echo "â”‚                                                      â”‚"
    echo "â”‚  âš ï¸  You only need to REMEMBER the password!        â”‚"
    echo "â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜"
    echo ""
    read -p "Press Enter to launch the setup UI..."

    # Snapshot READY instances now so we can detect the NEW one after provisioning
    echo "ğŸ“¸ Snapshotting existing AlloyDB instances before provisioning..."
    BEFORE_INSTANCES=$(check_ready_instances 2>/dev/null || echo "")

    # Start the Flask UI in the background â€” disowned immediately so bash never
    # prints "Terminated" when we kill it later
    mkdir -p "$SCRIPT_DIR/logs"
    cd "$SCRIPT_DIR/easy-alloydb-setup"
    sh run.sh > "$SCRIPT_DIR/logs/alloydb-setup-ui.log" 2>&1 &
    FLASK_PID=$!
    disown "$FLASK_PID" 2>/dev/null || true
    cd "$SCRIPT_DIR"

    # Wait for port 8080 to be accepting connections (up to 15s)
    echo ""
    echo -n "â³ Waiting for setup UI to start"
    UI_READY=0
    for i in $(seq 1 15); do
        sleep 1
        echo -n "."
        if curl -s -o /dev/null http://localhost:8080 2>/dev/null; then
            UI_READY=1
            break
        fi
    done
    echo ""
    if [ $UI_READY -eq 1 ]; then
        echo "âœ… Setup UI is running â€” open Web Preview on port 8080 now"
    else
        echo "âš ï¸  UI may still be starting. Open Web Preview on port 8080 in a moment."
    fi
    echo ""

    # Poll gcloud every 30s for a new READY instance.
    # Each poll prints a heartbeat line to prevent Cloud Shell idle timeout.
    echo "â³ Monitoring for new AlloyDB instance (checking every 30 seconds)..."
    echo "   Provisioning typically takes ~15 minutes."
    echo "   If this terminal disconnects, re-run: sh setup.sh"
    echo ""

    POLL_COUNT=0
    MAX_POLLS=70   # 35 minutes at 30s intervals
    ALLOYDB_READY=0

    while [ $POLL_COUNT -lt $MAX_POLLS ]; do
        ELAPSED_MIN=$(( POLL_COUNT * 30 / 60 ))
        ELAPSED_SEC=$(( (POLL_COUNT * 30) % 60 ))
        printf "   [%02d:%02d] Checking for new READY instance...\n" "$ELAPSED_MIN" "$ELAPSED_SEC"

        CURRENT_INSTANCES=$(check_ready_instances 2>/dev/null || echo "")

        # Detect genuinely new instances by set-difference with the baseline snapshot
        NEW_INSTANCE=$(python3 -c "
import sys
before  = set(filter(None, '''$BEFORE_INSTANCES'''.strip().splitlines()))
current = set(filter(None, '''$CURRENT_INSTANCES'''.strip().splitlines()))
new = current - before
if new:
    print(sorted(new)[0])
" 2>/dev/null)

        if [ -n "$NEW_INSTANCE" ]; then
            echo ""
            parse_instance_uri "$NEW_INSTANCE"
            echo "âœ… New AlloyDB instance detected!"
            echo ""
            echo "   Cluster:  $ALLOYDB_CLUSTER"
            echo "   Instance: $ALLOYDB_INSTANCE"
            echo "   Region:   $ALLOYDB_REGION"
            echo ""
            read -p "Continue setup with this instance? (Y/n): " -n 1 -r
            echo ""
            if [[ $REPLY =~ ^[Nn]$ ]]; then
                echo "   OK â€” continuing to wait for a different instance..."
                echo ""
            else
                ALLOYDB_READY=1
                # Checkpoint 2: persist cluster details immediately
                update_env_key "ALLOYDB_CLUSTER"  "$ALLOYDB_CLUSTER"
                update_env_key "ALLOYDB_INSTANCE" "$ALLOYDB_INSTANCE"
                update_env_key "ALLOYDB_REGION"   "$ALLOYDB_REGION"
                update_env_key "ALLOYDB_PROJECT"  "$PROJECT"
                break
            fi
        fi

        POLL_COUNT=$((POLL_COUNT + 1))
        sleep 30
    done

    # Stop the Flask UI server
    kill "$FLASK_PID" 2>/dev/null || true
    sleep 1
    pkill -f "easy-alloydb-setup" 2>/dev/null || true
    sleep 1

    echo ""
    if [ $ALLOYDB_READY -eq 1 ]; then
        echo "âœ… AlloyDB is READY! Cluster: $ALLOYDB_CLUSTER in $ALLOYDB_REGION"
        echo "   Continuing setup automatically..."
    else
        echo "âš ï¸  Timed out waiting for AlloyDB (35 minutes)."
        echo "   If provisioning completed in the UI, re-run: sh setup.sh"
    fi
    echo ""
    echo "âœ… Infrastructure provisioning complete!"
    echo ""
fi

# ============================================================================
# Step 4: Database Connection Setup
# ============================================================================
echo "ğŸ“¡ Step 4/5: Preparing database connection..."
echo ""

# First, detect AlloyDB instance(s)
echo "ğŸ” Detecting AlloyDB instance..."
INSTANCES=$(gcloud alloydb instances list --format="value(name)" 2>/dev/null)

if [ -z "$INSTANCES" ]; then
    # Try fallback from .env file variables
    if [ -n "$ALLOYDB_PROJECT" ] && [ -n "$ALLOYDB_REGION" ] && [ -n "$ALLOYDB_CLUSTER" ] && [ -n "$ALLOYDB_INSTANCE" ]; then
        INSTANCE_URI="projects/$ALLOYDB_PROJECT/locations/$ALLOYDB_REGION/clusters/$ALLOYDB_CLUSTER/instances/$ALLOYDB_INSTANCE"
        echo "âœ… Using instance from .env: ${ALLOYDB_CLUSTER}/${ALLOYDB_INSTANCE}"
    else
        echo "âŒ ERROR: No AlloyDB instance found"
        echo ""
        echo "Troubleshooting:"
        echo "  1. Verify deployment completed successfully in the UI"
        echo "  2. Check your GCP project: gcloud config get-value project"
        echo "  3. List all instances: gcloud alloydb instances list"
        echo "  4. If instance exists, manually add to .env file:"
        echo "     ALLOYDB_CLUSTER=your-cluster-name"
        echo "     ALLOYDB_INSTANCE=your-instance-name"
        echo "     ALLOYDB_REGION=your-region"
        echo ""
        exit 1
    fi
else
    # Count instances
    INSTANCE_COUNT=$(echo "$INSTANCES" | wc -l | tr -d ' ')
    
    if [ "$INSTANCE_COUNT" -eq 1 ]; then
        # Only one instance, use it automatically
        INSTANCE_URI="$INSTANCES"
        parse_instance_uri "$INSTANCE_URI"
        echo "âœ… Found instance: ${ALLOYDB_CLUSTER}/${ALLOYDB_INSTANCE} in ${ALLOYDB_REGION}"
    else
        # Multiple instances, let user choose
        echo "âœ… Found $INSTANCE_COUNT AlloyDB instances:"
        echo ""
        
        # Create array of instances
        i=1
        declare -a INSTANCE_ARRAY
        while IFS= read -r instance; do
            parse_instance_uri "$instance"
            echo "  $i) ${ALLOYDB_CLUSTER}/${ALLOYDB_INSTANCE} (${ALLOYDB_REGION})"
            INSTANCE_ARRAY[$i]="$instance"
            i=$((i + 1))
        done <<< "$INSTANCES"
        
        echo ""
        read -p "Select instance number (1-$INSTANCE_COUNT): " CHOICE
        
        if [ "$CHOICE" -ge 1 ] && [ "$CHOICE" -le "$INSTANCE_COUNT" ]; then
            INSTANCE_URI="${INSTANCE_ARRAY[$CHOICE]}"
            parse_instance_uri "$INSTANCE_URI"
            echo "âœ… Selected: ${ALLOYDB_CLUSTER}/${ALLOYDB_INSTANCE} in ${ALLOYDB_REGION}"
        else
            echo "âŒ Invalid selection"
            exit 1
        fi
    fi
fi

# Checkpoint 3: persist finalized instance details (may differ from checkpoint 2
# if the user selected a different instance in the interactive prompt)
if [ -n "$ALLOYDB_CLUSTER" ]; then
    update_env_key "ALLOYDB_CLUSTER"  "$ALLOYDB_CLUSTER"
    update_env_key "ALLOYDB_INSTANCE" "$ALLOYDB_INSTANCE"
    update_env_key "ALLOYDB_REGION"   "$ALLOYDB_REGION"
    update_env_key "ALLOYDB_PROJECT"  "$PROJECT"
fi

# Get database password
if [ -z "$DB_PASS" ]; then
    echo ""
    echo "âš ï¸  Database password not found"
    echo ""
    read -s -p "Enter your AlloyDB password from the setup UI: " DB_PASS
    echo ""
    export DB_PASS
fi

# Checkpoint 4: persist DB_PASS so re-runs don't ask again
update_env_key "DB_PASS" "$DB_PASS"

echo ""
echo "âœ… Database password configured"

# Generate .env file with all collected information
if [ -n "$GEMINI_API_KEY" ] && [ -n "$DB_PASS" ]; then
    generate_env_file "$PROJECT" "$GEMINI_API_KEY" "$DB_PASS" "$ALLOYDB_CLUSTER" "$ALLOYDB_INSTANCE" "$ALLOYDB_REGION"
fi

echo ""

# ============================================================================
# Setup Application Default Credentials for Auth Proxy
# ============================================================================

echo "ğŸ” Checking authentication for AlloyDB Auth Proxy..."
echo ""

ADC_PATH="$HOME/.config/gcloud/application_default_credentials.json"

# Check if running on GCE/Cloud Shell
IS_GCE=0
if curl -s -H "Metadata-Flavor: Google" http://metadata.google.internal/computeMetadata/v1/instance/id > /dev/null 2>&1; then
    IS_GCE=1
    echo "âœ… Running on Google Cloud Shell / GCE"
    echo ""
    
    # Even on Cloud Shell, we need user credentials (not VM service account)
    # because the metadata service often has OAuth token issues
    if [ ! -f "$ADC_PATH" ]; then
        echo "âš ï¸  Application Default Credentials not found"
        echo ""
        echo "On Cloud Shell, the Auth Proxy needs YOUR user credentials"
        echo "(not the VM's service account) to avoid OAuth errors."
        echo ""
        echo "This is a one-time setup (~30 seconds)."
        echo ""
        read -p "Set up credentials now? (Y/n): " -n 1 -r
        echo ""
        if [[ ! $REPLY =~ ^[Nn]$ ]]; then
            echo ""
            mkdir -p "$HOME/.config/gcloud"
            
            echo "Running: gcloud auth application-default login"
            echo ""
            echo "â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”"
            echo "â”‚  A browser link will be shown                 â”‚"
            echo "â”‚  1. Copy and open the link in your browser    â”‚"
            echo "â”‚  2. Sign in with your Google account          â”‚"
            echo "â”‚  3. Click 'Allow'                             â”‚"
            echo "â”‚  4. Copy the authorization code               â”‚"
            echo "â”‚  5. Paste it back here                        â”‚"
            echo "â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜"
            echo ""
            
            gcloud auth application-default login --no-launch-browser
            
            # Check if it saved to /tmp (Cloud Shell issue)
            TEMP_ADC=$(find /tmp -name "application_default_credentials.json" 2>/dev/null | head -n 1)
            if [ -n "$TEMP_ADC" ] && [ -f "$TEMP_ADC" ]; then
                echo ""
                echo "ğŸ“‹ Moving credentials to standard location..."
                cp "$TEMP_ADC" "$ADC_PATH"
                chmod 600 "$ADC_PATH"
                echo "âœ… Credentials saved to $ADC_PATH"
            elif [ -f "$ADC_PATH" ]; then
                echo ""
                echo "âœ… Application Default Credentials configured"
            else
                echo ""
                echo "âš ï¸  Credentials setup completed, but file location unclear"
                echo "   Auth Proxy may have issues - re-run 'sh setup.sh' if needed"
            fi
        else
            echo "âš ï¸  Skipping credential setup - Auth Proxy will likely fail"
            echo "   Re-run 'sh setup.sh' later to fix authentication"
        fi
    else
        echo "âœ… Application Default Credentials found"
    fi
else
    # Not on GCE - local machine
    if [ ! -f "$ADC_PATH" ]; then
        echo "âš ï¸  Application Default Credentials not found"
        echo ""
        echo "The Auth Proxy needs credentials to connect to AlloyDB."
        echo "This is a one-time setup that takes ~30 seconds."
        echo ""
        read -p "Set up credentials now? (Y/n): " -n 1 -r
        echo ""
        if [[ ! $REPLY =~ ^[Nn]$ ]]; then
            echo ""
            echo "Running: gcloud auth application-default login"
            echo ""
            echo "â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”"
            echo "â”‚  A browser will open (or show a link)         â”‚"
            echo "â”‚  1. Sign in with your Google account          â”‚"
            echo "â”‚  2. Click 'Allow'                             â”‚"
            echo "â”‚  3. Copy the authorization code               â”‚"
            echo "â”‚  4. Paste it back here                        â”‚"
            echo "â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜"
            echo ""
            
            gcloud auth application-default login
            
            if [ $? -eq 0 ]; then
                echo ""
                echo "âœ… Application Default Credentials configured"
            else
                echo ""
                echo "âŒ Failed to set up credentials"
                echo "   You can set up later with: gcloud auth application-default login"
                echo "   Continuing anyway..."
            fi
        else
            echo "âš ï¸  Skipping credential setup - Auth Proxy may fail"
        fi
    else
        echo "âœ… Application Default Credentials found"
    fi
fi

echo ""

# Download and start Auth Proxy
echo "ğŸ”Œ Starting AlloyDB Auth Proxy..."

# Detect OS and architecture
OS=$(detect_os)
ARCH=$(detect_arch)

PROXY_VERSION="v1.10.0"

case "$OS" in
    linux)
        if [ "$ARCH" = "arm64" ]; then
            PROXY_URL="https://storage.googleapis.com/alloydb-auth-proxy/${PROXY_VERSION}/alloydb-auth-proxy.linux.arm64"
        else
            PROXY_URL="https://storage.googleapis.com/alloydb-auth-proxy/${PROXY_VERSION}/alloydb-auth-proxy.linux.amd64"
        fi
        ;;
    darwin)
        if [ "$ARCH" = "arm64" ]; then
            PROXY_URL="https://storage.googleapis.com/alloydb-auth-proxy/${PROXY_VERSION}/alloydb-auth-proxy.darwin.arm64"
        else
            PROXY_URL="https://storage.googleapis.com/alloydb-auth-proxy/${PROXY_VERSION}/alloydb-auth-proxy.darwin.amd64"
        fi
        ;;
    *)
        echo "âš ï¸  Unknown OS: $OS, defaulting to Linux amd64"
        PROXY_URL="https://storage.googleapis.com/alloydb-auth-proxy/${PROXY_VERSION}/alloydb-auth-proxy.linux.amd64"
        ;;
esac

PROXY_BINARY="$SCRIPT_DIR/alloydb-auth-proxy"

# Function to download proxy
download_proxy() {
    echo "ğŸ“¥ Downloading Auth Proxy ${PROXY_VERSION} for $OS/$ARCH..."
    # Remove old binary if exists
    rm -f "$PROXY_BINARY"
    
    if command -v wget &> /dev/null; then
        wget -q "$PROXY_URL" -O "$PROXY_BINARY" 2>&1
    else
        curl -s -o "$PROXY_BINARY" "$PROXY_URL"
    fi
    chmod +x "$PROXY_BINARY"
    echo "âœ… Downloaded successfully"
}

# Download proxy if needed or validate existing
if [ ! -f "$PROXY_BINARY" ]; then
    download_proxy
else
    echo "âœ… Auth Proxy binary already exists"
    # Ensure it's executable
    chmod +x "$PROXY_BINARY" 2>/dev/null || true
    
    # Quick validation: check if binary is valid
    if ! "$PROXY_BINARY" --version > /dev/null 2>&1; then
        echo "âš ï¸  Existing binary appears corrupted or incompatible"
        echo "   Architecture: $OS/$ARCH"
        echo ""
        read -p "   Re-download Auth Proxy? (Y/n): " -n 1 -r
        echo ""
        if [[ ! $REPLY =~ ^[Nn]$ ]]; then
            download_proxy
        else
            echo "âš ï¸  Continuing with existing binary (may fail)"
        fi
    fi
fi

echo "âœ… Using instance: ${INSTANCE_URI}"

# Set explicit credentials path if ADC exists
if [ -f "$ADC_PATH" ]; then
    export GOOGLE_APPLICATION_CREDENTIALS="$ADC_PATH"
    echo "   Using credentials: $ADC_PATH"
fi

# ============================================================================
# Check and enable Public IP (required for Cloud Shell)
# ============================================================================
echo ""
echo "ğŸŒ Checking AlloyDB Public IP status..."
PUBLIC_IP=$(gcloud alloydb instances describe "$ALLOYDB_INSTANCE" \
    --cluster="$ALLOYDB_CLUSTER" \
    --region="$ALLOYDB_REGION" \
    --format="value(publicIpAddress)" 2>/dev/null)

if [ -n "$PUBLIC_IP" ]; then
    echo "âœ… Public IP already enabled: $PUBLIC_IP"
else
    echo "âš ï¸  Public IP is not enabled on this AlloyDB instance."
    echo ""
    # Cloud Shell cannot reach AlloyDB private IPs directly
    if [ -n "$CLOUD_SHELL" ] || [ -d /google ]; then
        echo "   Cloud Shell detected. Public IP is REQUIRED for connectivity."
    else
        echo "   If you're outside the AlloyDB VPC, Public IP is required."
    fi
    echo ""
    echo "   Security note: Public IP + Auth Proxy is secure because:"
    echo "   - All connections are mTLS encrypted via the Auth Proxy"
    echo "   - IAM authentication is required (no anonymous access)"
    echo "   - Password complexity is enforced (password.enforce_complexity=on)"
    echo ""
    read -p "   Enable Public IP now? (Y/n): " -n 1 -r
    echo ""
    if [[ $REPLY =~ ^[Nn]$ ]]; then
        echo "   âš ï¸  Skipping Public IP enablement. Proxy may fail if not on the VPC."
    else
        echo "   Enabling Public IP (this takes ~2 minutes)..."
        if gcloud alloydb instances update "$ALLOYDB_INSTANCE" \
            --cluster="$ALLOYDB_CLUSTER" \
            --region="$ALLOYDB_REGION" \
            --assign-inbound-public-ip=ASSIGN_IPV4 \
            --database-flags=password.enforce_complexity=on \
            --quiet 2>&1; then
            echo "   â³ Waiting for Public IP to be assigned..."
            for i in {1..24}; do
                sleep 5
                PUBLIC_IP=$(gcloud alloydb instances describe "$ALLOYDB_INSTANCE" \
                    --cluster="$ALLOYDB_CLUSTER" \
                    --region="$ALLOYDB_REGION" \
                    --format="value(publicIpAddress)" 2>/dev/null)
                if [ -n "$PUBLIC_IP" ]; then
                    echo "   âœ… Public IP assigned: $PUBLIC_IP"
                    echo "   â³ Waiting 60s for AlloyDB API to register the new IP..."
                    sleep 60
                    echo "   âœ… Propagation wait complete"
                    break
                fi
                echo -n "."
            done
            if [ -z "$PUBLIC_IP" ]; then
                echo ""
                echo "   âš ï¸  Public IP not yet available. It may still be provisioning."
                echo "   Re-run setup.sh in a few minutes."
            fi
        else
            echo "   âŒ Failed to enable Public IP. You may need to do this manually:"
            echo "   gcloud alloydb instances update $ALLOYDB_INSTANCE \\"
            echo "     --cluster=$ALLOYDB_CLUSTER --region=$ALLOYDB_REGION \\"
            echo "     --assign-inbound-public-ip=ASSIGN_IPV4 \\"
            echo "     --database-flags=password.enforce_complexity=on"
        fi
    fi
fi

# ============================================================================
# Configure Authorized Networks for Public IP Access
# ============================================================================
if [ -n "$PUBLIC_IP" ]; then
    echo ""
    echo "ğŸ”’ Checking authorized networks configuration..."
    
    # Check if 0.0.0.0/0 is already authorized
    CURRENT_NETWORKS=$(gcloud alloydb instances describe "$ALLOYDB_INSTANCE" \
        --cluster="$ALLOYDB_CLUSTER" \
        --region="$ALLOYDB_REGION" \
        --format="value(clientConnectionConfig.requireConnectors)" 2>/dev/null)
    
    # For local development outside GCP, we need to authorize external access
    if [ -z "$CLOUD_SHELL" ] && [ ! -d /google ]; then
        echo "   Local machine detected (not Cloud Shell/GCE)"
        echo ""
        echo "   âš ï¸  SECURITY WARNING:"
        echo "   To connect from your local machine, AlloyDB needs authorized networks configured."
        echo ""
        echo "   Options:"
        echo "   1. Authorize 0.0.0.0/0 (any IP) - Convenient for development/testing"
        echo "   2. Authorize only your current IP - More secure"
        echo "   3. Skip - Only works if you're on the VPC or using Cloud NAT"
        echo ""
        echo "   Note: Even with 0.0.0.0/0, connections are secure because:"
        echo "   - Auth Proxy requires valid GCP credentials (ADC)"
        echo "   - All traffic is mTLS encrypted"
        echo "   - Database password is still required"
        echo ""
        read -p "   Configure authorized networks? (1=All IPs/2=My IP/N=Skip): " -n 1 -r
        echo ""
        
        # Local machines always need --public-ip flag
        USE_PUBLIC_IP_FLAG="--public-ip"
        
        if [[ $REPLY =~ ^[1]$ ]]; then
            echo "   Authorizing all external IPs (0.0.0.0/0)..."
            if gcloud alloydb instances update "$ALLOYDB_INSTANCE" \
                --cluster="$ALLOYDB_CLUSTER" \
                --region="$ALLOYDB_REGION" \
                --authorized-external-networks=0.0.0.0/0 \
                --quiet 2>&1; then
                echo "   âœ… Authorized networks configured: 0.0.0.0/0"
            else
                echo "   âš ï¸  Failed to configure authorized networks"
                echo "   You can configure manually:"
                echo "   gcloud alloydb instances update $ALLOYDB_INSTANCE \\"
                echo "     --cluster=$ALLOYDB_CLUSTER --region=$ALLOYDB_REGION \\"
                echo "     --authorized-external-networks=0.0.0.0/0"
            fi
        elif [[ $REPLY =~ ^[2]$ ]]; then
            echo "   Getting your current IP address..."
            MY_IP=$(curl -s https://api.ipify.org)
            if [ -n "$MY_IP" ]; then
                echo "   Your IP: $MY_IP"
                echo "   Authorizing $MY_IP/32..."
                if gcloud alloydb instances update "$ALLOYDB_INSTANCE" \
                    --cluster="$ALLOYDB_CLUSTER" \
                    --region="$ALLOYDB_REGION" \
                    --authorized-external-networks="$MY_IP/32" \
                    --quiet 2>&1; then
                    echo "   âœ… Authorized networks configured: $MY_IP/32"
                else
                    echo "   âš ï¸  Failed to configure authorized networks"
                fi
            else
                echo "   âŒ Could not determine your IP address"
            fi
        else
            echo "   Skipping authorized networks configuration"
            echo "   âš ï¸  Connection may fail if you're not on the VPC"
        fi
    else
        echo "   Cloud Shell/GCE detected - checking VPC connectivity..."
        
        # Even in Cloud Shell, if AlloyDB is in a custom VPC (not default),
        # we need to use Public IP because Cloud Shell can't reach it privately
        ALLOYDB_NETWORK=$(gcloud alloydb instances describe "$ALLOYDB_INSTANCE" \
            --cluster="$ALLOYDB_CLUSTER" \
            --region="$ALLOYDB_REGION" \
            --format="value(network)" 2>/dev/null)
        
        if [[ "$ALLOYDB_NETWORK" == *"default"* ]]; then
            echo "   âœ… AlloyDB in default VPC - private connectivity available"
            USE_PUBLIC_IP_FLAG=""
        else
            echo "   âš ï¸  AlloyDB in custom VPC - will use Public IP connection"
            echo "   Note: Cloud Shell cannot reach custom VPCs via private IP"
            USE_PUBLIC_IP_FLAG="--public-ip"
        fi
    fi
fi

# Check if proxy is already running
EXISTING_PROXY_PID=$(pgrep -f "alloydb-auth-proxy" 2>/dev/null | head -n 1)
if [ -n "$EXISTING_PROXY_PID" ]; then
    echo "ğŸ”„ Existing Auth Proxy found (PID: $EXISTING_PROXY_PID)"
    echo "   Stopping old proxy to ensure clean restart..."
    kill $EXISTING_PROXY_PID 2>/dev/null || true
    sleep 2
fi

echo "ğŸš€ Starting Auth Proxy with fresh credentials..."

# Ensure logs directory exists
mkdir -p "$SCRIPT_DIR/logs"

# Determine connection method based on Public IP availability
if [ -n "$PUBLIC_IP" ] && [ -z "$USE_PUBLIC_IP_FLAG" ]; then
    # Public IP exists but we're in Cloud Shell with default VPC - let proxy auto-detect
    echo "   Starting proxy with automatic connection detection..."
    nohup "$PROXY_BINARY" "$INSTANCE_URI" > "$SCRIPT_DIR/logs/proxy.log" 2>&1 &
elif [ -n "$PUBLIC_IP" ]; then
    # Public IP exists and we need to use it explicitly
    echo "   Using Public IP: $PUBLIC_IP"
    nohup "$PROXY_BINARY" "$INSTANCE_URI" --public-ip > "$SCRIPT_DIR/logs/proxy.log" 2>&1 &
else
    # No Public IP - must use private IP
    echo "   Using private IP connection..."
    nohup "$PROXY_BINARY" "$INSTANCE_URI" > "$SCRIPT_DIR/logs/proxy.log" 2>&1 &
fi

PROXY_PID=$!
echo "   PID: $PROXY_PID (logs: logs/proxy.log)"

# Wait for proxy to be ready - check for actual connection readiness
echo -n "   Waiting for proxy to initialize"
PROXY_READY=0
CONNECTION_ERRORS=0

for i in {1..30}; do
    echo -n "."
    sleep 1
    
    # Check if process died
    if ! kill -0 $PROXY_PID 2>/dev/null; then
        echo ""
        echo "âŒ Auth Proxy process died. Checking logs..."
        echo ""
        
        # Check for specific error patterns
        if grep -q "Bus error" "$SCRIPT_DIR/logs/proxy.log" 2>/dev/null; then
            echo "âš ï¸  BINARY CORRUPTION DETECTED (Bus error)"
            echo ""
            echo "The Auth Proxy binary is corrupted or incompatible with your system."
            echo "Architecture: $OS/$ARCH"
            echo ""
            echo "FIX: Re-download the correct binary:"
            echo "  1. Remove corrupted binary: rm alloydb-auth-proxy"
            echo "  2. Re-run setup: sh setup.sh"
            echo ""
            echo "Or manually download:"
            echo "  wget $PROXY_URL -O alloydb-auth-proxy && chmod +x alloydb-auth-proxy"
        elif grep -q "oauth2.*invalid token" "$SCRIPT_DIR/logs/proxy.log" 2>/dev/null; then
            echo "âš ï¸  AUTHENTICATION ERROR"
            echo ""
            echo "FIX: Run this command and re-run setup:"
            echo "  gcloud auth application-default login --no-launch-browser"
        else
            echo "ğŸ“‹ Last 15 lines from logs/proxy.log:"
            tail -15 "$SCRIPT_DIR/logs/proxy.log"
            echo ""
            echo "Common causes:"
            echo "  1. Binary corruption (Bus error) - Delete and re-download"
            echo "  2. Missing credentials - Run: gcloud auth application-default login"
            echo "  3. Insufficient permissions - Check IAM roles"
            echo "  4. AlloyDB API not enabled properly"
        fi
        exit 1
    fi
    
    # Check for OAuth errors in log
    if grep -q "oauth2.*invalid token" "$SCRIPT_DIR/logs/proxy.log" 2>/dev/null; then
        CONNECTION_ERRORS=1
    fi
    
    # Check if proxy is actually listening and ready (look for success message)
    if grep -q "ready for new connections" "$SCRIPT_DIR/logs/proxy.log" 2>/dev/null; then
        PROXY_READY=1
        # Give it 2 more seconds to fully stabilize
        sleep 2
        break
    fi
done
echo ""

if [ $CONNECTION_ERRORS -eq 1 ]; then
    echo "âš ï¸  Auth Proxy started but has OAuth authentication errors"
    echo ""
    echo "Quick fix: Run this command and follow the prompts:"
    echo "   gcloud auth application-default login --no-launch-browser"
    echo ""
    echo "Then restart:"
    echo "   kill $PROXY_PID"
    echo "   ./alloydb-auth-proxy $INSTANCE_URI > logs/proxy.log 2>&1 &"
    echo ""
    read -p "Try to continue anyway? (y/N): " -n 1 -r
    echo ""
    if [[ ! $REPLY =~ ^[Yy]$ ]]; then
        exit 1
    fi
elif [ $PROXY_READY -eq 1 ]; then
    echo "âœ… Auth Proxy started successfully and ready for connections"
else
    echo "âš ï¸  Auth Proxy started but may need more time"
    echo "   Check logs/proxy.log if database connection fails"
fi

echo ""

# ============================================================================
# Step 5: Seed Database
# ============================================================================
echo "ğŸŒ± Step 5/5: Seeding database..."
echo ""

# Run seed script
echo "Creating schema and inserting sample data..."
cd "$SCRIPT_DIR/database"
python3 seed.py

if [ $? -eq 0 ]; then
    echo ""
    echo "âœ… Database seeded successfully!"
    
    # Generate test vectors for verification
    echo ""
    echo "ğŸ“¦ Generating test vectors for verification..."
    # The test_vectors.json file already exists with pre-computed embeddings
    # This step is a placeholder for future automated generation
    if [ -f "$SCRIPT_DIR/agents/supplier-agent/test_vectors.json" ]; then
        echo "âœ… Test vectors file confirmed at agents/supplier-agent/test_vectors.json"
    else
        echo "âš ï¸  Warning: test_vectors.json not found (verification may use fallback)"
    fi
else
    echo ""
    echo "âŒ Database seeding failed"
    if grep -q "does not have IP of type" "$SCRIPT_DIR/logs/proxy.log" 2>/dev/null; then
        echo ""
        echo "âš ï¸  The AlloyDB public IP hasn't fully propagated to the API yet."
        echo "   Restarting Auth Proxy and retrying in 60 seconds..."
        echo ""
        kill "$(pgrep -f alloydb-auth-proxy)" 2>/dev/null || true
        sleep 60
        if [ -n "$USE_PUBLIC_IP_FLAG" ]; then
            nohup "$PROXY_BINARY" "$INSTANCE_URI" --public-ip > "$SCRIPT_DIR/logs/proxy.log" 2>&1 &
        else
            nohup "$PROXY_BINARY" "$INSTANCE_URI" > "$SCRIPT_DIR/logs/proxy.log" 2>&1 &
        fi
        sleep 5
        echo "Retrying database seed..."
        cd "$SCRIPT_DIR/database"
        python3 seed.py
        if [ $? -ne 0 ]; then
            echo ""
            echo "âŒ Retry also failed. Re-run 'sh setup.sh' in a few minutes."
            exit 1
        fi
        cd "$SCRIPT_DIR"
    else
        echo "   Check that DB_PASS is correct and Auth Proxy is running"
        exit 1
    fi
fi

cd "$SCRIPT_DIR"

# ============================================================================
# Setup Complete
# ============================================================================
echo ""
echo "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—"
echo "â•‘                  Setup Complete!                     â•‘"
echo "â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£"
echo "â•‘  IMPORTANT: Complete the codelab steps FIRST!        â•‘"
echo "â•‘                                                      â•‘"
echo "â•‘  Then start the application:                         â•‘"
echo "â•‘  â€¢ Run 'sh run.sh' to start all services             â•‘"
echo "â•‘  â€¢ Open http://localhost:8080                        â•‘"
echo "â•‘  â€¢ Upload an image and watch the magic!              â•‘"
echo "â•‘                                                      â•‘"
echo "â•‘  Sample images: assets/samples/                      â•‘"
echo "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
echo ""
if [ -f "$SCRIPT_DIR/.env" ]; then
    echo "ğŸ’¾ Configuration saved to .env file"
    echo "   Future runs will automatically load these settings"
else
    echo "âš ï¸  .env file not created (missing credentials)"
    echo ""
    echo "To create .env manually, set these environment variables:"
    echo "  export GEMINI_API_KEY='your-api-key'"
    echo "  export GOOGLE_CLOUD_PROJECT=$PROJECT"
    echo "  export DB_PASS='your-password'"
fi
echo ""
